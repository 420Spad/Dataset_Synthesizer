<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>NVIDIA DeepLearning Dataset Synthesizer (NDDS): Broker</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NVIDIA DeepLearning Dataset Synthesizer (NDDS)
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('broker.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Broker </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
<p> <a class="anchor" id="contents"></a> </p><h1>Contents:</h1>
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#context">Context</a></li>
<li><a href="#broker">Broker Usage</a></li>
<li><a href="#client">Client Libraries and Usage</a></li>
<li><a href="#compile">Compilation</a></li>
<li><a href="#examples">Extended examples</a><ul>
<li><a href="#example1">Configuring DLEnvironment and DLTrainer to use the broker</a></li>
<li><a href="#example2">Client callbacks in Python</a></li>
</ul>
</li>
</ul>
<hr/>
<p> <a class="anchor" id="summary"></a> </p><h1>Summary</h1>
<p>(<a href="#contents">Back to Contents</a>)</p>
<p><b>DLBroker</b> is a router for connecting simulations to (possibly remote) processes training neural networks. While it is specifically designed to be used as part of the DLToolkit, in conjunction with the DLEnvironment library and <a href="https://ls-gitswarm.nvidia.com/eleitch/DLTrainer">DLTrainer</a> framework (more below), it is effectively a general-purpose message broker that additionally provides auto-routing logic for messages between specialized deep-learning clients. It is intended to provide a fast, scalable routing service for multiple simulation environments communicating with multiple trainers.</p>
<p>This repo provides the DLBroker application, a C++ client library for connecting to the broker, and a Python module built on top of the same C++ client library, providing a single client interface for deep-learning simulations implemented in C++ and neural-network implementations running in Python.</p>
<p>DLBroker is designed so that both the broker and client code can be be compiled and run on Linux, BSD, or Windows platforms. Compilation for Windows and Unix variants is described <a href="#compile">below</a>.</p>
<hr/>
<p> <a class="anchor" id="context"></a> </p><h1>Context</h1>
<p>(<a href="#contents">Back to Contents</a>)</p>
<p>The general problem of simulations using reinforcement learning (RL) requires that at each step of the simulation, state data for AI instances can be pushed to a neural network, and that the network return appropriate actions to the AI instances.</p>
<p>Traditionally, this requires strong coupling between the simulation generating state data and the RL networks consuming it. This is less than ideal in a research context, because of platform mismatch between data generation (Windows, for gaming sims for example) and neural-network processing (often unix-based), and also because it makes on-the-fly reconfiguration of sims, or rapid iteration in developing network implementations, difficult at best.</p>
<p><br />
 The DLToolkit includes several components to address these issues: <br />
 <br />
</p>
<p><b>DLEnvironment</b> The DLEnvironment library provides a simple layer allowing for decoupling of data generation and processing, by providing a generic remote interface as a C++ DLL that can be integrated with a simulation to provide the capability to configure AI instances on the fly, and that allows the sim to communicate state data and receive actions from a remote training service. The remote framework uses simple JSON configuration files to specify the trainer IP address and port, and the trainer provides the AI configuration when the sim connects.</p>
<p><b>DLTrainer</b> The DLTrainer codebase provides a general-purpose Python framework for receiving and processing data from multiple sim environments, and batching and routing the data between multiple network implementations. The framework allows network implementations to be written as standalone modules and deployed within the framework, provided they adhere to a simple API. With the remote framework provided by the DLEnvironment library, the trainer can be stopped and restarted and any running sims will automatically reconnect.</p>
<p><b>DLBroker</b> The combination of DLEnvironment and DLTrainer provides a generic <em>many-to-one</em> architecture, allowing many sim environments to send data simultaneously to a single trainer (possibly running multiple network implementations). DLBroker extends this architecture to support <em>many-to-many</em> connections. Trainers and sim environments connect to the broker instead of each other, and the broker handles auto-routing between data generators (sim environments) and data consumers (trainers).</p>
<ul>
<li>This allows many instances of a sim environment to be run without needing separate configuration files for each instance (all environments connect to the same broker, instead of to separate trainers)</li>
<li>Allows the broker to automatically handle routing of data between simulation environments and the trainers that can consume them.</li>
<li>Allows the broker to balance data distribution among connected trainers.</li>
<li>Allows sim data to be forwarded to multiple trainers (i.e., for supervised learning applications, or separate control of AI instances by different servers)</li>
</ul>
<p><br />
 In the context of the DLToolkit components, the broker's role is indicated schematically below:</p>
<div class="image">
<img src="images/DLToolkitArch.png"  align="center" alt="DLToolkit Architecture" width="50%"/>
</div>
<hr/>
<p> <a class="anchor" id="broker"></a> </p><h1>Broker Usage</h1>
<p>Currently DLBroker provides a simple executable that is invoked with the following optional parameters:</p>
<p><code>DLBroker [port=9505] [verbose=f] [highwatermark="0B"] [lowwatermark="0B"] [nthread=10]</code></p>
<p>(defaults are shown above).</p>
<p>Parameters are:</p>
<ul>
<li><code>port</code> The port on which the broker should listen, which defaults to 9505.</li>
<li><code>verbose</code> Set to true to print more information about what the broker is doing.</li>
<li><code>highwatermark</code> This is a desired cap on the broker's memory usage. If specified, the broker will attempt to limit instantaneous memory consumption to the specified limit. To make this more human-friendly to specify, it expects a string like "500 kB", "100MB", or "1.2 GB". Be careful &ndash; I pedantically distinguish between "b" (bits) and "B" (bytes). When a non-zero value is given for the high-water mark, the broker will throttle communications if internal memory consumption reaches this limit.</li>
<li><code>lowwatermark</code> To be used in conjunction with the high-water mark. If the broker throttles comms at the high-water mark, they will be unthrottled when the memory consumption drops to the low-water mark. This provides some hysteresis, preventing the system from constantly throttling/unthrottling at the high-water mark as individual messages are consumed. If not specified, the broker defaults to 80% of the high-water mark.</li>
<li><code>nthread</code> This determines how many worker threads the broker master spawns to handle requests. You generally won't care about this, but on a CPU-bound multi-core system, this can be used to optimize throughput by allowing the system scheduler to deploy worker threads on independent cores.</li>
</ul>
<p>Once deployed, the broker listens for connection requests from broker clients, and processes messages passed between connected clients. Supported clients and associated behaviors are detailed below.</p>
<hr/>
<p> <a class="anchor" id="client"></a> </p><h1>Client Libraries and Usage</h1>
<p>(<a href="#contents">Back to Contents</a>)</p>
<p>By default DLBroker supports the following client types and behaviors:</p>
<ul>
<li><b>BrokerClient</b> A generic broker client, which can publish data to arbitrary channels, and subscribe to arbitrary channels. Maps to C++ and Python <code>BrokerClient</code> classes.</li>
<li><b>AutoBrokerClient</b> A generic broker client, to which the broker automatically assigns publish and reply channels. Maps to C++ and Python <code>AutoBrokerClient</code> classes.</li>
<li><b>DLEnvironmentBrokerClient</b> A specialized type of AutoBrokerClient for use with the DLEnvironment library. This client advertises a simulation type to the broker, and has channels automatically assigned when it connects. It supports a set of DL-specific messages (see below), and messages sent to the broker by this client are automatically routed to appropriate trainers (see <a href="#dlenvusage">usage description</a> below), by simulation type. Maps to C++ and Python <code>DLEnvironmentBrokerClient</code> classes.</li>
<li><b>DLTrainerBrokerClient</b> A specialized type of AutoBrokerClient for use with the DLTrainer RL service. This client advertises a list of simulation types it can process when it connects to the broker. When clients of type DLEnvironmentBrokerClient connect to the broker, messages from them are auto-routed to DLTrainerBrokerClient clients, matched by simulation type. Maps to C++ and Python <code>DLTrainerBrokerClient</code> classes.`</li>
</ul>
<p>All supported clients will automatically connect to the broker, and re-establish a connection to the broker if a network partion occurs, or if the broker process is restarted.</p>
<p><a class="anchor" id="clientusage"></a> </p><h2>Client Usage Examples</h2>
<h3>BrokerClient</h3>
<p>The generic broker client acts like a traditional message-broker client. It supports simple <code>subscribe</code> and <code>publish</code> methods:</p>
<p><br />
 **C++**</p>
<p>The entry point to the DLL is via the BrokerUtils.h header. Clients should be instantiated anad destroyed via the corresponding factory methods in BrokerUtils:</p>
<p>```cpp using namespace DLBroker; BrokerClient* client = BrokerUtils::newBrokerClient(); ```</p>
<p>The client APIs are documented in the headers for the coresponding clases. For example, to publish a message using a BrokerClient, use the <code>publish</code> method:</p>
<p>```cpp client-&gt;publish("mychannel", "test message"); ```</p>
<p>or</p>
<p>```cpp client-&gt;publish("mychannel", "test message", size, bytePtr); ```</p>
<p>for binary message content, where <code>bytePtr</code> is a pointer to raw binary data.</p>
<p>A typical usage pattern is to subscribe to a set of channels, and register a handler to be called whenever a message is read from the broker:</p>
<p>```cpp client-&gt;registerReadHandler(handlerFn, handlerArgs); client-&gt;subscribe("mychannel"); client-&gt;subscribe("anotherchannel"); ```</p>
<p>In the example above, <code>handlerFn</code> would be called with <code>handlerArgs</code> as the last argument whenever a message is received on channels <code>mychannel</code> or <code>anotherchannel</code>. (See <code>BrokerTypes.h</code> included from <code>BrokerUtils.h</code> for the declaration of <code>handlerFn</code>).</p>
<p><br />
 <b>Python</b></p>
<p>The Python module <code>pyBrokerClient</code> supplies a similar interface to the client library:</p>
<p>```python &gt;&gt;&gt; import pyBrokerClient as pbc &gt;&gt;&gt; client = pbc.BrokerClient() &gt;&gt;&gt; client.publish("mychannel", "test message") ```</p>
<p>The example below subscribes to channel <code>mychannel</code> and calls the <code>print()</code> function whenever a message is received.</p>
<p>```python &gt;&gt;&gt; client.registerReadHandler(print, None) &gt;&gt;&gt; client.subscribe('mychannel') ```</p>
<p>Any Python method invoked with incorrect arguments will print a synopsis of expected arguments. For example:</p>
<p>```python &gt;&gt;&gt; client.registerReadHandler() ... ValueError:</p>
<p>Usage: registerReadHandler(handlerFn, handlerArgs) </p><pre class="fragment">where handlerFn should be handlerFn(channel, lastReadStr, handlerArgs)
</pre><p>&gt;&gt;&gt; ```</p>
<p><a class="anchor" id="dlenvusage"></a> </p><h3>DLEnvironmentBrokerClient</h3>
<p>In general, DL environments and trainers support a very simple communications loop, based on the following logic:</p>
<ul>
<li>A sim environment can send a healthcheck request to get status information about whether a trainer is present to process its data.</li>
<li>Each cycle of a simulation is referred to as an <em>experiment</em>, and each experiment consists of <em>episodes</em>, which can consist of an arbitrary number of simulation <em>ticks</em>.</li>
<li>The trainer controls how many ticks constitute an episode, and how many episodes constitute an experiment.</li>
<li>When the trainer communicates that an episode has ended, the sim environment is expected to start a new episode, and when the trainer communicates that an experiment has ended, the environment is expected to start a new experiment.</li>
</ul>
<p><br />
 **C++**</p>
<p>A new DLEnvironment client is instantiated via a factory method in BrokerUtils:</p>
<p>```cpp using namespace DLBroker; DLEnvironmentBrokerClient* client = BrokerUtils::newDLEnvironmentBrokerClient("SimpleTrainingApp"); ```</p>
<p>DLEnvironmentBrokerClient supports methods for each of the logical steps listed above:</p>
<p>```cpp std::string resp; if(client-&gt;healthcheck(resp) == SocketConnection::READ_DONE) {</p>
<p>// Check response to see if servers are present</p>
<p>if(serversArePresent(resp)) {</p>
<p>client-&gt;experimentstart(resp); unsigned expId = getExperimentId(resp);</p>
<p>client-&gt;episodestart(formatEpisodeStartData(expId), resp); client-&gt;tick(formatTickData(expId), resp);</p>
<p>processActions(resp); ... } } ```</p>
<p><a class="anchor" id="dltrainerusage"></a> </p><h3>DLTrainerBrokerClient</h3>
<p><br />
 <b>Python</b></p>
<p>A new DLTrainer client is instantiated from the <code>pyBrokerClient</code> module. For example:</p>
<p>```python &gt;&gt;&gt; import pyBrokerClient as pbc &gt;&gt;&gt; client = pbc.DLTrainerBrokerClient(['SimpleApp', 'AleApp']) ```</p>
<p>instantiates a DLTrainer client that tells the broker it can process data from simulation types <code>SimpleApp</code> and 'AleApp`. DlEnvironment clients that produce data of those types will be auto-routed by the broker to this client.</p>
<hr/>
<p> <a class="anchor" id="compile"></a> </p><h1>Compilation</h1>
<p>(<a href="#contents">Back to Contents</a>)</p>
<p>These notes are specific to the DLToolkit repository. In what follows, we refer to the top of your DLToolkit branch (e.g., <code>NVStudios/DLToolkit/Main</code>) as <code>$TOP</code>.</p>
<p>In the context of DLToolkit, the broker projects are included as part of $TOP/Source/DLToolkit.sln. On Windows platforms, load the <code>$TOP/Source/DLToolkit.sln</code> file into Visual Studio.</p>
<p>For Windows configurations, building the solution should create the following, in <code>$TOP/Out/bin/$Platform/$Configuration</code>:</p>
<table class="doxtable">
<tr>
<td><code>DLBroker/DLBroker.exe</code> </td><td>The broker executable </td></tr>
<tr>
<td><code>DLBroker/DLBrokerLib.lib</code> </td><td>The broker library needed to use the clients from C++ </td></tr>
<tr>
<td><code>pyBrokerClientDLL/pyBrokerClientDLL.pyd</code> </td><td>The Python library needed to use the clients from Python </td></tr>
<tr>
<td><code>pyBrokerClientDLL/pyBrokerClient.py</code> </td><td>The Python client module built on top of pyBrokerClientDLL. This is intended to be your primary interface to the client library, rather than using pyBrokerClientDLL directl </td></tr>
</table>
<p><br />
</p>
<p>For Linux configurations, building the solution should create the following, in <code>$TOP/Out/bin/$Platform/$Configuration</code>:</p>
<table class="doxtable">
<tr>
<td><code>DLBroker/DLBroker</code> </td><td>The broker executable </td></tr>
<tr>
<td><code>DLBroker/libDLBrokerLib.so</code> </td><td>The broker library needed to use the clients from C++ </td></tr>
<tr>
<td><code>pyBrokerClientDLL/pyBrokerClientDLL.so</code> </td><td>The Python library needed to use the clients from Python </td></tr>
<tr>
<td><code>pyBrokerClientDLL/pyBrokerClient.py</code> </td><td>The Python client module built on top of pyBrokerClientDLL. This is intended to be your primary interface to the client library, rather than using pyBrokerClientDLL directl </td></tr>
</table>
<p>NB: On any platform, you will have to add <code>$TOP/Out/bin/$Platform/$Configuration/pyBrokerClientDLL</code> to your <code>PYTHONPATH</code> in order to load the <code>pyBrokerClient</code> module.</p>
<hr/>
<p> <a class="anchor" id="examples"></a> </p><h1>Extended examples</h1>
<p>(<a href="#contents">Back to Contents</a>)</p>
<p><a class="anchor" id="example1"></a> </p><h2>Configuring DLEnvironment and DLTrainer to use the broker</h2>
<p>The following example walks through some of the steps required to use the broker with the DLEnvironment and DLTrainer codebase. It assumes that the broker executable is running on the localhost, listening on port 9505.</p>
<p>Suppose you have a simulation <code>SimpleTrainingApp</code> that is compiled with DLEnvironment support. Let' say the executable directory for <code>SimpleTrainingApp</code> is located at <code>$stadir</code>, which also contains a subdirectory <code>$stadir/Configuration</code> where it looks for local configuration files.</p>
<p>Suppose that <code>DLTrainer</code> is installed in <code>$dltrainerdir</code>, which contains JSON config files under directory <code>$dltrainerdir/config</code>, and network implementation modules are located somewhere in your PYTHONPATH.</p>
<p>We want to control <code>SimpleTrainingApp</code> from a neural network running in <code>DLTrainer</code>, via the DLBroker executable. To do this, we require only that both be told what IP address and port to use for communication with the broker.</p>
<p>We accomplish this for the trainer by creating a config file (say <code>$dltrainerdir/config/DLTrainer/Trainer_Config.json</code>) like:</p>
<p>``` { "RL" : { "BrokerAddress" : "localhost:9505",</p>
<p>"Modules" : ["../simpleTrainingApp/Trainer_Config.json"] } } ```</p>
<p>The <code>BrokerAddress</code> keyword tells <code>DLTrainer</code> the IP address and port to use for communication with the broker, for use with the RL service of the DLTrainer. (See DLTrainer documentation for more details on configuring the trainer services).</p>
<p>We start the trainer like (powershell):</p>
<p>``` &amp; python DLTrainer.py trainerconfig=$dltrainerdir/config/DLTrainer/Trainer_Config.json ```</p>
<p>This tells the trainer to use <code>$dltrainerdir/config/DLTrainer/Trainer_Config.json</code> as its config.</p>
<p>For the <code>SimpleTrainingApp</code>, we modify its configuration <code>$stadir/Configuration/Remote_Config.json</code> to read:</p>
<p>``` { "BrokerAddress": "127.0.0.1:9505", "SimType": "SimpleTrainingApp" } ```</p>
<p>The first line tells the DLEnvironment interface the IP address and port to use for communication with the broker, and the second line is the tag that the broker will use to identify the type of simulation data that we are sending. If it matches one of the tags registered by a <code>DLTrainer</code> instance connected to the broker, data for this sim will be automatically routed to that trainer.</p>
<p>We start the app like (powershell):</p>
<p>``` &amp; cd $stadir; ./SimpleTrainingApp.exe Configuration Local_Config.json ```</p>
<p>(where <code>$stadir/Configuration/Local_Config.json</code> is a local configuration file that would be used if not configured to talk to a remote trainer (i.e., if <code>Remote_Config.json</code> is empty))</p>
<p>And that's it!</p>
<p>The app should now be talking to the trainer. If multiple instances of the app are started, they will all be connected by the broker to the same trainer process. If multiple <code>DLTrainer</code> processes are started, the broker will distribute data from all connected instances of <code>SimpleTrainingApp</code> evenly among the trainer processes.</p>
<p>New instances of <code>SimpleTrainingApp</code> can be attached to the broker, and their data will be immediately routed to attached trainers. Likewise, new <code>DLTrainer</code> instances can be attached, and they will begin processing data.</p>
<p>If the broker is restarted, the <code>SimpleTrainingApp</code> and <code>DLTrainer</code> processes will reattach to the broker and resume communication.</p>
<p><a class="anchor" id="example2"></a> </p><h2>Client callbacks in Python</h2>
<p>The broker also supports general pub/sub clients. The following example demonstrates use of the broker to spawn powershell processes remotely from Python. This example assumes that the broker executable is running on the localhost on port 9505.</p>
<p>```python import pyBrokerClient as pbc import subprocess</p>
<p>def powershellCallback(channel, msg, args): subprocess.call(["C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\powershell.exe", msg])</p>
<p>client = pbc.BrokerClient("127.0.0.1", 9505) client.registerReadHandler(powershellCallback, None) client.subscribe("pscmd") ```</p>
<p>Sending messages to the channel <code>pscmd</code> will spawn the corresponding powershell process on the host machine.</p>
<p>The read handler is registered on the client (Python) side, so will remain in effect across restarts of the broker. But the subscribe command is a command to the broker &ndash; that state is therefore lost if the broker is restarted.</p>
<p>You can preserve state across broker restarts by placing stateful commands in a connection callback function &ndash; this will be called by the client whenever a connection is established to the broker. For example, adding the following code to the example above would ensure that the client subscribes to the pscmd channel whenever a connection to the broker is re-established:</p>
<p>```python def connectCallback(client): client.subscribe("pscmd")</p>
<p>client.registerConnectHandler(connectCallback, client) ``` </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 2 2018 10:26:35 for NVIDIA DeepLearning Dataset Synthesizer (NDDS) by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
